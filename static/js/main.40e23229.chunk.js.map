{"version":3,"sources":["Button.tsx","RecipeList.tsx","RecipeDetail.tsx","API.ts","EditableRecipeDetail.tsx","ComponentWrapper.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Button","styled","button","withRouter","props","recipes","sort","a","b","id","map","recipe","key","to","name","onClick","history","push","historyPush","description","ingredients","ingredient","index","removeFunction","API_URL","process","deleteRecipe","fetch","method","mode","patchRecipe","headers","body","JSON","stringify","postRecipe","initRecipe","useState","setRecipe","useEffect","length","concat","value","onChange","e","target","newName","updatedIngredients","i","filteredIngredients","filter","_","handleIngredientChange","preventDefault","action","ComponentWrapper","children","message","text","App","reloadData","state","setState","setMessage","recipeById","parseInt","removeRecipeById","Api","then","response","handleResponse","editRecipe","ok","type","res","json","catch","error","console","log","timer","setTimeout","clearTimeout","className","exact","path","render","match","params","Boolean","window","location","hostname","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.40e23229.chunk.js","sourcesContent":["import styled from \"styled-components\";\n\nexport const Button = styled.button`\n  margin: 0.5em 1em;\n  padding: 0.25em 1em;\n`;\n","import React from \"react\";\nimport { IRecipe } from \"./Types\";\nimport { Link, withRouter, RouteComponentProps } from \"react-router-dom\";\nimport { Button } from \"./Button\";\n\ninterface Props {\n  recipes: IRecipe[];\n}\n\nfunction RecipeList(props: Props & RouteComponentProps) {\n  if (!props.recipes) {\n    return <h3>Loading...</h3>;\n  }\n  return (\n    <>\n      <h2>List of my recipes</h2>\n      <ul>\n        {props.recipes\n          .sort((a, b) => a.id! - b.id!)\n          .map((recipe) => (\n            <li key={recipe.id}>\n              <Link to={`/recipe/${recipe.id}`}>{recipe.name}</Link>\n            </li>\n          ))}\n      </ul>\n      <Button onClick={() => props.history.push(\"/recipe/add\")}>Add</Button>\n    </>\n  );\n}\n\nexport default withRouter(RecipeList);\n","import React from \"react\";\nimport { IRecipe } from \"./Types\";\nimport { withRouter, RouteComponentProps } from \"react-router-dom\";\nimport { Button } from \"./Button\";\n\ninterface Props {\n  recipe: IRecipe;\n  removeFunction: (arg0: number) => void;\n}\n\nfunction RecipeDetail(props: Props & RouteComponentProps) {\n  let recipe = props.recipe;\n  let historyPush = props.history.push;\n\n  const handleRemove = () => {\n    props.removeFunction(recipe.id!);\n    historyPush(\"/\");\n  };\n  if (!recipe) {\n    return <h3>Loading...</h3>;\n  }\n\n  return (\n    <>\n      <h2>Recipe detail:</h2>\n      <h2>{recipe.name}</h2>\n      <div>{recipe.description}</div>\n      <h4>Ingredients: </h4>\n      {recipe.ingredients.map((ingredient, index) => (\n        <li key={index}>{ingredient.name}</li>\n      ))}\n      <Button onClick={() => historyPush(\"/recipe/\" + recipe.id + \"/edit\")}>\n        Edit\n      </Button>\n      <Button onClick={handleRemove}> Delete </Button>\n      <Button onClick={() => historyPush(\"/\")}>Back</Button>\n    </>\n  );\n}\n\nexport default withRouter(RecipeDetail);\n","import { IRecipe } from \"./Types\";\n\nconst API_URL = process.env.REACT_APP_BACKEND!;\n\nconst getAllRecipes = () =>\n  fetch(API_URL, {\n    method: \"GET\",\n    mode: \"cors\",\n  });\n\nconst deleteRecipe = (id: number) =>\n  fetch(`${API_URL}${id}/`, {\n    method: \"DELETE\",\n    mode: \"cors\",\n  });\n\nconst patchRecipe = (recipe: IRecipe) =>\n  fetch(`${API_URL}${recipe.id}/`, {\n    method: \"PATCH\",\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(recipe),\n  });\n\nconst postRecipe = (recipe: IRecipe) =>\n  fetch(API_URL, {\n    method: \"POST\",\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(recipe),\n  });\n\nexport { postRecipe, getAllRecipes, deleteRecipe, patchRecipe };\n","import React, { useState, useEffect } from \"react\";\nimport { RouteComponentProps, withRouter } from \"react-router-dom\";\nimport { IRecipe } from \"./Types\";\nimport { Button } from \"./Button\";\n\ninterface Props {\n  recipe?: IRecipe;\n  action: (arg: IRecipe) => void;\n}\n\nfunction EditableRecipeDetail(props: Props & RouteComponentProps) {\n  const initRecipe = props.recipe\n    ? props.recipe\n    : {\n        name: \"\",\n        description: \"\",\n        ingredients: [],\n      };\n  const [recipe, setRecipe] = useState(initRecipe);\n\n  useEffect(() => {\n    if (\n      recipe.ingredients.length === 0 ||\n      recipe.ingredients[recipe.ingredients.length - 1].name !== \"\"\n    ) {\n      setRecipe({\n        ...recipe,\n        ingredients: recipe.ingredients.concat([{ name: \"\" }]),\n      });\n    }\n  }, [recipe]);\n\n  useEffect(() => {\n    if (props.recipe) {\n      setRecipe(props.recipe);\n    }\n  }, [props.recipe]);\n\n  const handleIngredientChange = (index: number, newName: string) => {\n    // Remove empty ingredient\n    if (newName === \"\") {\n      let filteredIngredients = recipe.ingredients.filter(\n        (_, i) => (index = i)\n      );\n\n      setRecipe({ ...recipe, ingredients: filteredIngredients });\n      return;\n    }\n    // Update ingredient\n    const updatedIngredients = recipe.ingredients.map((ingredient, i) => {\n      if (index === i) {\n        return {\n          name: newName,\n        };\n      } else {\n        return { name: ingredient.name };\n      }\n    });\n    setRecipe({ ...recipe, ingredients: updatedIngredients });\n  };\n\n  const handleBack = () => {\n    if (recipe.id) {\n      props.history.push(`/recipe/${recipe.id}`);\n    } else {\n      props.history.push(\"/\");\n    }\n  };\n\n  return (\n    <>\n      <h2>Edit or add recipe:</h2>\n      <form>\n        Name:\n        <input\n          value={recipe.name}\n          onChange={(e) => setRecipe({ ...recipe, name: e.target.value })}\n        />\n        Description:\n        <input\n          value={recipe.description}\n          onChange={(e) =>\n            setRecipe({ ...recipe, description: e.target.value })\n          }\n        />\n        Ingredients:\n        <ol>\n          <ul>\n            {recipe.ingredients.map((ingredient, index) => {\n              return (\n                <input\n                  key={index}\n                  value={ingredient.name}\n                  onChange={(e) =>\n                    handleIngredientChange(index, e.target.value)\n                  }\n                ></input>\n              );\n            })}\n          </ul>\n        </ol>\n        <Button\n          onClick={(e) => {\n            e.preventDefault();\n            props.action(recipe);\n          }}\n        >\n          Save\n        </Button>\n        <Button onClick={handleBack}>Back</Button>\n      </form>\n    </>\n  );\n}\n\nexport default withRouter(EditableRecipeDetail);\n","import React, { FunctionComponent } from \"react\";\nimport { Message } from \"./App\";\n\ninterface Props {\n  message?: Message;\n  children: React.ReactNode;\n}\n\nconst ComponentWrapper: FunctionComponent<Props> = (props: Props) => {\n  return (\n    <>\n      <h1>My recipe database</h1>\n      {props.children}\n      <h3>{props.message?.text}</h3>\n    </>\n  );\n};\n\nexport default ComponentWrapper;\n","import React, { useEffect, useState } from \"react\";\nimport { BrowserRouter as Router, Switch, Route } from \"react-router-dom\";\nimport RecipeList from \"./RecipeList\";\nimport RecipeDetail from \"./RecipeDetail\";\nimport { IRecipe } from \"./Types\";\nimport \"milligram\";\nimport * as Api from \"./API\";\nimport EditableRecipeDetail from \"./EditableRecipeDetail\";\nimport ComponentWrapper from \"./ComponentWrapper\";\n\ninterface IState {\n  recipes: IRecipe[];\n  reloadData: boolean;\n}\n\nexport interface Message {\n  text?: String;\n  type?: String;\n}\n\nfunction App() {\n  const [state, setState] = useState<IState>({\n    recipes: [],\n    reloadData: false,\n  });\n\n  const [message, setMessage] = useState<Message>({});\n  function recipeById(id: string) {\n    return state.recipes.filter((recipe) => recipe.id === parseInt(id))[0];\n  }\n\n  async function removeRecipeById(id: number) {\n    await Api.deleteRecipe(id).then((response) =>\n      handleResponse(response, \"delete recipe\")\n    );\n  }\n\n  async function editRecipe(recipe: IRecipe) {\n    recipe.ingredients = recipe.ingredients.filter(\n      (ingredient) => ingredient.name !== \"\"\n    );\n\n    await Api.patchRecipe(recipe).then((response) =>\n      handleResponse(response, \"update recipe\")\n    );\n  }\n\n  async function addRecipe(recipe: IRecipe) {\n    recipe.ingredients = recipe.ingredients.filter(\n      (ingredient) => ingredient.name !== \"\"\n    );\n    await Api.postRecipe(recipe).then((response) =>\n      handleResponse(response, \"create recipe\")\n    );\n  }\n\n  const handleResponse = (response: Response, method: string) => {\n    let message: Message = {};\n    if (!response.ok) {\n      message.text = `Error: ${method} has failed.`;\n      message.type = \"error\";\n    } else {\n      message.text = `Success: ${method}`;\n      setState({\n        ...state,\n        reloadData: !state.reloadData,\n      });\n    }\n    setMessage(message);\n  };\n\n  useEffect(() => {\n    Api.getAllRecipes()\n      .then((res) => res.json())\n      .then((json) =>\n        setState({\n          recipes: json,\n          reloadData: state.reloadData,\n        })\n      )\n      .catch((error) => console.log(error));\n  }, [state.reloadData]);\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setMessage({});\n    }, 2000);\n    return () => clearTimeout(timer);\n  });\n\n  return (\n    <Router>\n      <div className=\"App\">\n        <div className=\"container\">\n          <Switch>\n            <Route exact path=\"/\">\n              <ComponentWrapper message={message}>\n                <RecipeList recipes={state.recipes} />\n              </ComponentWrapper>\n            </Route>\n            <Route exact path=\"/recipe/add\">\n              <ComponentWrapper message={message}>\n                <EditableRecipeDetail action={addRecipe} />\n              </ComponentWrapper>\n            </Route>\n            <Route\n              exact\n              path=\"/recipe/:id\"\n              render={(props) => (\n                <ComponentWrapper message={message}>\n                  <RecipeDetail\n                    removeFunction={removeRecipeById}\n                    recipe={recipeById(props.match.params.id)}\n                  />\n                </ComponentWrapper>\n              )}\n            ></Route>\n            <Route\n              exact\n              path=\"/recipe/:id/edit\"\n              render={(props) => (\n                <ComponentWrapper message={message}>\n                  <EditableRecipeDetail\n                    recipe={recipeById(props.match.params.id)}\n                    action={editRecipe}\n                  />\n                </ComponentWrapper>\n              )}\n            ></Route>\n          </Switch>\n        </div>\n      </div>\n    </Router>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}